MODULE operator(id, inChan, outChan, busy, counter)
ASSIGN
    next(busy[id]) := case
            inChan = start | busy[1-id] = FALSE : TRUE;
            inChan = stop | outChan = stop : FALSE;
            TRUE : busy[id]; 
        esac;
    next(outChan) := case
            inChan = start & busy[id] = TRUE : ack;
            inChan = data & busy[id] = TRUE : data;
            inChan = stop & busy[id] = TRUE : stop;
            busy[1-id] = FALSE & busy[id] = TRUE : start;
            (inChan = ack | inChan = data) & busy[id] = TRUE & counter < 3 : data;
            (inChan = ack | inChan = data) & busy[id] = TRUE & counter = 3 : stop;
            TRUE : outChan;
        esac;
    next(counter) := case
            outChan = data & busy[id] = TRUE & counter < 3 : counter+1;
            outChan = stop & busy[id] = TRUE & counter = 3 : 0;
            TRUE : counter;
        esac;
FAIRNESS 
    running

MODULE main
VAR
    busy: array 0..1 of boolean;
    counter: 0 .. 3;
    up0: {start , stop , data , ack};
    down0: {start , stop , data , ack};
    up1: {start , stop , data , ack};
    down1: {start , stop , data , ack};
    operator_1: process operator(0, up1, down1, busy, counter);
    operator_2: process operator(1, up0, down0, busy, counter);
    operator_3: process operator(0, down0, up0, busy, counter);
    operator_4: process operator(1, down1, up1, busy, counter);
ASSIGN
    init(counter) := 0;
    init(busy[0]) := FALSE;
    init(busy[1]) := FALSE;
    init(up0) := start;
    init(up1) := start;
    init(down0) := start;
    init(down1) := start;

LTLSPEC G ((up0 = start -> F (up0 = stop)) & (up1 = start -> F (up1 = stop)) & (down0 = start -> F (down0 = stop)) & (down1 = start -> F (down1 = stop)))