MODULE mutex(i, flag, turn) --Peterson's Algorithm
VAR
    state: {s0, s1, s2};
ASSIGN
init(state) := s0;
next(state) := case
        (flag[i] = TRUE & (flag[1-i] = FALSE | turn = i)) & state = s0 : s1; -- critical section
        (flag[i] = TRUE & (flag[1-i] = FALSE | turn = i)) & state = s1 : s2;
        (flag[i] = TRUE & (flag[1-i] = FALSE | turn = i)) & state = s2 : s0;
        TRUE : state;
    esac;
next(flag[i]) := case 
        state = s0 : TRUE; -- want to enter critical section 
        state = s2 : FALSE; -- end of critical section, b[i] := false
        TRUE : flag[i];
    esac;
next(turn) := case
        state = s2 : 1 - i; -- k = 1 - i
        TRUE : turn;
    esac;
FAIRNESS 
    running

MODULE main
VAR
    flag: array 0..1 of boolean;
    turn: 0..1;
    proc_0: process mutex(0, flag, turn);
    proc_1: process mutex(1, flag, turn);
ASSIGN
    init(turn) := 0;
    init(flag[0]) := FALSE;
    init(flag[1]) := FALSE;

-- when turn = i or flag [1 - i] = false, critical section
LTLSPEC G !((flag[0] = TRUE & (turn = 0 | flag[1] = FALSE)) & (flag[1] = TRUE & (turn = 1 | flag[0] = FALSE)))
-- starvation-free : all processes that enter the loop eventually exit it
LTLSPEC G((turn = 1 & flag[1] = TRUE) -> F(turn = 0 | flag[1] = FALSE))
LTLSPEC G((turn = 0 & flag[0] = TRUE) -> F(turn = 1 | flag[0] = FALSE))
